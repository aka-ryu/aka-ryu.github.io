---
layout: post
title: LIBRARY - Zod
category: LIBRARY
---

# Zod가 등장한 이유, 장단점, 그리고 기존 라이브러리의 한계

## ✅ Zod가 등장하게 된 배경

기존에 JavaScript/TypeScript에서 API 응답 데이터나 사용자 입력값을 검증하려면 수동으로 체크하거나, `Joi`, `Yup`, `class-validator` 같은 라이브러리를 사용해야 했다.

하지만 이들 대부분은 TypeScript와 100% 자연스럽게 연동되지 않았고, 타입은 따로 정의하고, 유효성 검사 스키마도 따로 정의해야 하는 번거로움이 존재했다.

Zod는 이러한 문제를 해결하고자 등장했다. **타입과 유효성 검사를 동시에 하나의 스키마로 선언할 수 있도록 설계되었다.**

---

## ⚠ 기존 라이브러리들의 한계

### 1. Yup

* 유효성 검사는 편리했지만, 타입 추론이 제한적이었다.
* `yup.InferType<typeof schema>`를 사용해도 복잡한 구조에서는 타입 추론이 정확하지 않았다.

**예시:**

```ts
import * as yup from 'yup';

const schema = yup.object({
  name: yup.string().required(),
  age: yup.number().optional(),
});

type Data = yup.InferType<typeof schema>; // 타입 추론이 제한되었다
```

### 2. class-validator + class-transformer

* 데코레이터 방식으로 작성되어 OOP 스타일에 의존하게 되었다.
* 런타임에 타입 정보가 없어 `class-transformer`와 함께 사용해야 했고, 번들 사이즈도 커졌다.
* NestJS에선 유용했지만 함수형 코드에선 불필요하게 복잡한 구조를 강요받았다.

**예시:**

```ts
class User {
  @IsString()
  name: string;

  @IsOptional()
  @IsNumber()
  age?: number;
}
```

---

## 💡 Zod의 장점

| 항목         | 설명                                            |
| ---------- | --------------------------------------------- |
| 타입과 검증을 통합 | `z.object()`로 타입과 유효성 검사를 동시에 정의할 수 있었다       |
| 타입스크립트 친화적 | `z.infer<typeof schema>`를 사용해 정확한 타입 추론이 가능했다 |
| 체이닝 방식 지원  | Yup처럼 체이닝으로 유효성 규칙을 선언할 수 있었다                 |
| 런타임 검증 가능  | API 응답, Form 입력값 등 런타임에서 실제로 검증할 수 있었다        |
| DX 우수      | 자동완성 및 에러 메시지가 직관적으로 제공되었다                    |

**예시:**

```ts
import { z } from 'zod';

const UserSchema = z.object({
  name: z.string(),
  age: z.number().optional(),
});

type User = z.infer<typeof UserSchema>; // 타입 자동 추론되었다

UserSchema.parse({ name: '철수' }); // 통과되었다
UserSchema.parse({ name: '영희', age: '30' }); // 오류 발생되었다
```

---

## 🙁 Zod의 단점

| 항목            | 설명                                      |
| ------------- | --------------------------------------- |
| 런타임 오버헤드 존재   | 모든 검증이 런타임에서 실행되므로 성능에 민감한 코드엔 주의가 필요했다 |
| 메시지 커스터마이징 제한 | Yup에 비해 유효성 메시지를 세밀하게 커스터마이징하기 어려웠다     |
| 스키마 재사용 불편    | 중첩 구조가 복잡해질 경우 스키마 정의가 장황해졌다            |

---

## 🚀 Zod를 사용할 때 적합한 상황

* 타입스크립트를 기반으로 한 프로젝트에서
* API 응답이나 Form 입력값 검증이 빈번히 발생하는 상황에서
* Yup, Joi 등의 타입 연동 한계에 피로감을 느꼈던 경험이 있을 때
* 프레임워크 독립적으로 유효성 검증 로직을 구성하고자 할 때

---

## 🧪 실제 사용 예시 (API 응답 검증)

```ts
const response = await fetch('/api/user');
const data = await response.json();

const schema = z.object({
  id: z.string(),
  email: z.string().email(),
});

const parsed = schema.safeParse(data);

if (!parsed.success) {
  console.error(parsed.error);
} else {
  console.log(parsed.data.email); // 타입까지 정확하게 추론되었다
}
```

---

## 📌 정리

Zod는 기존의 타입 정의와 유효성 검사를 따로 관리해야 했던 구조를 개선하고자 등장했다.

"타입을 한 번만 정의하면 끝"이라는 간결한 접근을 통해 개발 생산성을 높였고,
TypeScript 프로젝트에서 신뢰도 높은 데이터 검증을 가능하게 만들었다.

---

## 🧩 class-validator vs Zod 실제 비교 사례

### 📦 상황: 회원가입 API (POST /signup)

```json
{
  "email": "user@example.com",
  "password": "abcd1234",
  "age": 20
}
```

조건:

* email은 이메일 형식
* password는 8자 이상
* age는 0 이상 숫자

---

### 1. class-validator 사용 (NestJS)

```ts
class SignupDto {
  @IsEmail()
  email: string;

  @MinLength(8)
  password: string;

  @IsInt()
  @Min(0)
  age: number;
}

@Post()
signup(@Body() dto: SignupDto) {
  return this.userService.createUser(dto);
}
```

이 코드는 ValidationPipe 없거나 외부 입력값이 직접 서비스로 들어오면 우회 가능했다.

```ts
this.userService.createUser({ email: 'a', password: 123, age: 'not number' });
```

→ 런타임 오류 발생 가능성이 존재했다.

---

### 2. Zod 사용 시

```ts
const SignupSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
  age: z.number().int().min(0),
});

const result = SignupSchema.safeParse(input);

if (!result.success) throw new Error('잘못된 입력값');

this.userService.createUser(result.data);
```

→ 한 번만 검증해두면 서비스 로직 안에선 재검증 필요가 없었다.

---

## ✅ 컴파일 타입 보장 vs 런타임 타입 보장 쉽게 이해하기

| 구분        | 설명                                  |
| --------- | ----------------------------------- |
| 컴파일 타입 보장 | 개발 중에 타입스크립트가 확인해주는 '약속 체크'였다       |
| 런타임 타입 보장 | 코드 실행 중 실제 값이 유효한지 확인해주는 '실물 확인'이었다 |

**예시:**

```ts
function login(user: { password: string }) {
  console.log(user.password.length);
}

login({ password: 1234 }); // 타입스크립트는 믿고 넘겼지만, 런타임 오류 발생했다
```

Zod 사용 시:

```ts
const schema = z.object({ password: z.string() });
const result = schema.safeParse({ password: 1234 });
if (!result.success) console.error('password는 string이어야 했다');
```

→ Zod는 실제 값까지 확인해서 런타임 오류를 막을 수 있었다.

---

**결론:** 타입스크립트의 타입 선언은 약속일 뿐이고,
Zod는 그 약속이 실제로 지켜졌는지 검사하는 역할을 수행했다.
