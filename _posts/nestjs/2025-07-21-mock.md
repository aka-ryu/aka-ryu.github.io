---
layout: post
title: NESTJS - 유닛테스트 Mock 사용 이유
category: NESTJS
---



NestJS에서 유닛 테스트를 작성할 때, 실제 구현체 대신 **모의 객체(Mock)** 를 사용하는 건 테스트 품질과 속도, 안정성에 직결된다. 단순히 "DB 없이 테스트한다" 수준을 넘어서, **의존성 분리와 예측 가능한 테스트**를 위해 꼭 필요한 개념이다.

---

## 1. 의존성 제거

유닛 테스트의 핵심은 **테스트 대상 클래스나 함수만** 검증하는 것이다. 그런데 해당 로직이 외부에 의존하고 있다면 테스트 결과가 외부 상태에 따라 달라질 수 있다.

```ts
// UserService가 UserRepository에 의존하는 상황
class UserService {
  constructor(private userRepository: UserRepository) {}

  findUser(id: string) {
    return this.userRepository.findById(id);
  }
}
```

이럴 경우, `userRepository`를 모의 객체로 대체해서 테스트를 고립시킬 수 있다.

---

## 2. 테스트 속도 향상

DB나 외부 API에 접근하면 테스트가 느려진다. 반면, Mock은 단순 객체라서 **빠르게 실행**된다.

```ts
const mockUserRepo = {
  findById: jest.fn().mockReturnValue({ id: '123', name: 'Ryu' }),
};
```

이런 방식으로 실제 DB 없이 결과를 시뮬레이션할 수 있다.

---

## 3. 예측 가능한 테스트

실제 데이터나 API 응답은 바뀔 수 있다. 하지만 Mock은 우리가 지정한 값만 반환하니까 항상 같은 결과가 나온다. → 테스트 신뢰성 확보.

---

## 4. 실패 상황 시뮬레이션 가능

에러 상황을 재현하기 위해 실제 DB를 일부러 고장낼 순 없다. Mock은 원하는 에러를 쉽게 만들 수 있다.

```ts
mockUserRepo.findById.mockImplementation(() => {
  throw new Error('DB error');
});
```

이렇게 해서 **예외 처리 로직까지** 테스트할 수 있다.

---

## 5. 유닛 테스트 본질 지키기

의존성까지 같이 테스트하면 그건 유닛 테스트가 아니라 통합 테스트에 가까워진다.  
유닛 테스트는 **딱 하나의 단위(클래스/함수)** 만 테스트하는 게 목적이기 때문에 mock이 반드시 필요하다.

---

## 정리

| 이유 | 설명 |
|------|------|
| 의존성 제거 | 테스트 대상만 격리 가능하게 해줌 |
| 테스트 속도 | DB 없이 실행되므로 매우 빠름 |
| 결과 예측 가능 | 언제나 같은 결과로 테스트 가능 |
| 에러 처리 검증 | 실패 상황도 쉽게 시뮬레이션 가능 |
| 유닛 테스트 원칙 준수 | 한 유닛 단위만 검증할 수 있음 |

---

추가로 `jest.fn()`, `jest.mock()`, `overrideProvider()` 같은 NestJS + Jest 환경에서의 mock 세팅 방법도 따로 정리해볼 수 있다.
