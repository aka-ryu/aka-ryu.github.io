---
layout: post
title: LIBRARY - TRPC
category: LIBRARY
---

# tRPC로 타입 안전하게 API 구성해보기 (React + NestJS)

프로젝트를 하다 보면 백엔드 API를 정의하고, 프론트에서 그걸 또 호출하는데...
매번 DTO 만들고, Swagger 보고, 타입 맞추고 이러는 게 솔직히 너무 귀찮다.


---

## 🔍 tRPC란?

`tRPC`는 타입스크립트 기반의 타입 안전한 API 프레임워크다.
GraphQL처럼 스키마를 따로 만들 필요도 없고, REST처럼 라우트 + DTO + 컨트롤러를 따로 만들 필요도 없다.

프론트에서 마치 백엔드 함수를 직접 호출하듯 사용할 수 있고, 백엔드와 타입이 완전히 연결되기 때문에
함수 시그니처가 바뀌면 프론트에서 바로 에러가 뜨니까 실수를 줄이는데도 꽤 도움이 된다.

---

## ✅ 장점 

### 1. 프론트/백엔드 타입 자동 연결

백엔드에서 함수 시그니처 바꾸면 프론트에서 바로 타입 에러 뜸.
이게 진짜 크다. 기존엔 백엔드에서 API 응답 타입 바꾸면 프론트는 Swagger 뒤지면서 수동으로 고쳐야 했는데,
이제는 그냥 타입스크립트가 다 잡아준다.

### 2. 함수처럼 API 호출

REST처럼 `axios.get('/user?id=1')` 이런 거 안 해도 됨.
그냥 `trpc.user.get.query({ id: 1 })` 이렇게 쓰면 된다. 실수 줄어들고 훨씬 직관적임.

### 3. 불필요한 Swagger, DTO, 인터페이스 제거

Nest 쓸 때마다 `@Controller`, `@Get`, `@Body`, DTO 이런 거 다 정의해야 했는데,
tRPC는 이런 거 안 해도 됨. zod로 input validation만 정의해주면 끝.

---

## ❌ 단점 

### 1. 프론트와 백이 같은 리포여야 편함

tRPC는 타입 공유가 전제인데, 프론트/백을 따로 레포지토리로 운영하면 공유가 불편하다.
이럴 땐 패키지로 타입만 따로 묶거나 해야 해서 귀찮음.

### 2. 외부 시스템과의 연동이 어려움

REST처럼 `GET /users/1` 이런 API는 외부에서 호출할 수 있는데,
tRPC는 함수 호출 기반이라 외부 업체에서 사용하려면 결국 REST API를 따로 만들어야 함.
(그래서 나는 웹훅이나 외부 API는 Nest Controller로 따로 빼고, 내부용은 tRPC로 분리함)

### 3. API 문서 없음

Swagger 같은 문서가 없음. 물론 타입으로 다 추론되긴 하는데,
신입 개발자나 외부 팀에게 설명하려면 결국 뭔가 문서나 샘플 코드를 따로 줘야 함.

---

## 💻 실전 예제: React + NestJS로 tRPC 연결하기

---

### 📁 디렉터리 구조

```
src/
├── app.module.ts
├── main.ts
├── trpc/
│   ├── trpc.adapter.ts
│   ├── trpc.router.ts
├── hello/
│   ├── hello.module.ts
│   ├── hello.service.ts
│   └── hello.trpc.ts
```

---

### 1. HelloService 작성

```ts
// src/hello/hello.service.ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class HelloService {
  getGreeting(name: string) {
    return `Hello from service, ${name}`;
  }
}
```

---

### 2. tRPC 라우터 정의

```ts
// src/hello/hello.trpc.ts
import { initTRPC } from '@trpc/server';
import { z } from 'zod';
import { HelloService } from './hello.service';

const t = initTRPC.context<Context>().create();

interface Context {
  helloService: HelloService;
}

export const createHelloRouter = (helloService: HelloService) =>
  t.router({
    hello: t.procedure
      .input(z.object({ name: z.string() }))
      .query(({ input }) => {
        return {
          message: helloService.getGreeting(input.name),
        };
      }),
  });
```

---

### 3. 전체 tRPC Router 조합

```ts
// src/trpc/trpc.router.ts
import { createHelloRouter } from '../hello/hello.trpc';
import { HelloService } from '../hello/hello.service';
import { initTRPC } from '@trpc/server';

const t = initTRPC.context<Context>().create();

interface Context {
  helloService: HelloService;
}

export const createAppRouter = (deps: { helloService: HelloService }) =>
  t.router({
    hello: createHelloRouter(deps.helloService),
  });

export type AppRouter = ReturnType<typeof createAppRouter>;
```

---

### 4. Nest에서 tRPC 미들웨어로 연결

```ts
// src/trpc/trpc.adapter.ts
import * as trpcExpress from '@trpc/server/adapters/express';
import { createAppRouter } from './trpc.router';
import { HelloService } from '../hello/hello.service';

export function createTrpcMiddleware(helloService: HelloService) {
  const appRouter = createAppRouter({ helloService });

  return trpcExpress.createExpressMiddleware({
    router: appRouter,
    createContext: () => ({ helloService }),
  });
}
```

---

### 5. 모듈 구성

```ts
// src/hello/hello.module.ts
import { Module } from '@nestjs/common';
import { HelloService } from './hello.service';

@Module({
  providers: [HelloService],
  exports: [HelloService],
})
export class HelloModule {}
```

---

### 6. main.ts에서 tRPC 등록

```ts
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { HelloService } from './hello/hello.service';
import { createTrpcMiddleware } from './trpc/trpc.adapter';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  const helloService = app.get(HelloService);

  app.use('/trpc', createTrpcMiddleware(helloService));

  await app.listen(3000);
}
bootstrap();
```

---

### 7. React에서 tRPC 호출

```tsx
import { createTRPCProxyClient, httpBatchLink } from '@trpc/client';
import type { AppRouter } from '../server/trpc/trpc.router';

const trpc = createTRPCProxyClient<AppRouter>({
  links: [
    httpBatchLink({
      url: 'http://localhost:3000/trpc',
    }),
  ],
});

trpc.hello.hello.query({ name: 'aka ryu' }).then((res) => {
  console.log(res.message); // Hello from service, aka ryu
});
```

---

## 📌 마무리

tRPC는 빠른 개발, 타입 안정성 측면에서는 확실히 장점이 많다.
특히 프론트랑 백을 한 명이 다 하거나, 작은 팀에서 쓰면 진짜 생산성이 좋음.
반대로, 외부에 API를 노출하거나 팀이 완전 분리된 구조에선 REST나 GraphQL이 여전히 더 나을 수 있다.
