---
layout: post
title: LIBRARY - Zod
category: LIBRARY
---

# Zod가 등장한 이유, 장단점, 그리고 기존 라이브러리의 한계

## ✅ Zod가 등장하게 된 배경

기존에 JavaScript/TypeScript에서 API 응답 데이터나 사용자 입력값을 검증하려면 수동으로 체크하거나, `Joi`, `Yup`, `class-validator` 같은 라이브러리를 사용해야 했다.

하지만 이들 대부분은 TypeScript와 100% 자연스럽게 연동되지 않았고, 타입은 따로 정의하고, 유효성 검사 스키마도 따로 정의해야 하는 번거로움이 존재했다.

Zod는 이러한 문제를 해결하고자 등장했다. **타입과 유효성 검사를 동시에 하나의 스키마로 선언할 수 있도록 설계되었다.**

---

## ⚠ 기존 라이브러리들의 한계

### 1. Yup

* 유효성 검사는 편리했지만, 타입 추론이 제한적이었다.
* `yup.InferType<typeof schema>`를 사용해도 복잡한 구조에서는 타입 추론이 정확하지 않았다.

**예시:**

```ts
import * as yup from 'yup';

const schema = yup.object({
  name: yup.string().required(),
  age: yup.number().optional(),
});

type Data = yup.InferType<typeof schema>; // 타입 추론이 제한되었다
```

### 2. class-validator + class-transformer

* 데코레이터 방식으로 작성되어 OOP 스타일에 의존하게 되었다.
* 런타임에 타입 정보가 없어 `class-transformer`와 함께 사용해야 했고, 번들 사이즈도 커졌다.
* NestJS에선 유용했지만 함수형 코드에선 불필요하게 복잡한 구조를 강요받았다.

**예시:**

```ts
class User {
  @IsString()
  name: string;

  @IsOptional()
  @IsNumber()
  age?: number;
}
```

---

## 💡 Zod의 장점

| 항목         | 설명                                            |
| ---------- | --------------------------------------------- |
| 타입과 검증을 통합 | `z.object()`로 타입과 유효성 검사를 동시에 정의할 수 있었다       |
| 타입스크립트 친화적 | `z.infer<typeof schema>`를 사용해 정확한 타입 추론이 가능했다 |
| 체이닝 방식 지원  | Yup처럼 체이닝으로 유효성 규칙을 선언할 수 있었다                 |
| 런타임 검증 가능  | API 응답, Form 입력값 등 런타임에서 실제로 검증할 수 있었다        |
| DX 우수      | 자동완성 및 에러 메시지가 직관적으로 제공되었다                    |

**예시:**

```ts
import { z } from 'zod';

const UserSchema = z.object({
  name: z.string(),
  age: z.number().optional(),
});

type User = z.infer<typeof UserSchema>; // 타입 자동 추론되었다

UserSchema.parse({ name: '철수' }); // 통과되었다
UserSchema.parse({ name: '영희', age: '30' }); // 오류 발생되었다
```

---

## 🙁 Zod의 단점

| 항목            | 설명                                      |
| ------------- | --------------------------------------- |
| 런타임 오버헤드 존재   | 모든 검증이 런타임에서 실행되므로 성능에 민감한 코드엔 주의가 필요했다 |
| 메시지 커스터마이징 제한 | Yup에 비해 유효성 메시지를 세밀하게 커스터마이징하기 어려웠다     |
| 스키마 재사용 불편    | 중첩 구조가 복잡해질 경우 스키마 정의가 장황해졌다            |

---

## 🚀 Zod를 사용할 때 적합한 상황

* 타입스크립트를 기반으로 한 프로젝트에서
* API 응답이나 Form 입력값 검증이 빈번히 발생하는 상황에서
* Yup, Joi 등의 타입 연동 한계에 피로감을 느꼈던 경험이 있을 때
* 프레임워크 독립적으로 유효성 검증 로직을 구성하고자 할 때

---

## 🧪 실제 사용 예시 (API 응답 검증)

```ts
const response = await fetch('/api/user');
const data = await response.json();

const schema = z.object({
  id: z.string(),
  email: z.string().email(),
});

const parsed = schema.safeParse(data);

if (!parsed.success) {
  console.error(parsed.error);
} else {
  console.log(parsed.data.email); // 타입까지 정확하게 추론되었다
}
```

---

## 📌 정리

Zod는 기존의 타입 정의와 유효성 검사를 따로 관리해야 했던 구조를 개선하고자 등장했다.

"타입을 한 번만 정의하면 끝"이라는 간결한 접근을 통해 개발 생산성을 높였고,
TypeScript 프로젝트에서 신뢰도 높은 데이터 검증을 가능하게 만들었다.
